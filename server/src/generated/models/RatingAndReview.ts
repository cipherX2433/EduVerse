
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `RatingAndReview` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model RatingAndReview
 * 
 */
export type RatingAndReviewModel = runtime.Types.Result.DefaultSelection<Prisma.$RatingAndReviewPayload>

export type AggregateRatingAndReview = {
  _count: RatingAndReviewCountAggregateOutputType | null
  _avg: RatingAndReviewAvgAggregateOutputType | null
  _sum: RatingAndReviewSumAggregateOutputType | null
  _min: RatingAndReviewMinAggregateOutputType | null
  _max: RatingAndReviewMaxAggregateOutputType | null
}

export type RatingAndReviewAvgAggregateOutputType = {
  rating: number | null
}

export type RatingAndReviewSumAggregateOutputType = {
  rating: number | null
}

export type RatingAndReviewMinAggregateOutputType = {
  id: string | null
  rating: number | null
  review: string | null
  userId: string | null
  courseId: string | null
  createdAt: Date | null
}

export type RatingAndReviewMaxAggregateOutputType = {
  id: string | null
  rating: number | null
  review: string | null
  userId: string | null
  courseId: string | null
  createdAt: Date | null
}

export type RatingAndReviewCountAggregateOutputType = {
  id: number
  rating: number
  review: number
  userId: number
  courseId: number
  createdAt: number
  _all: number
}


export type RatingAndReviewAvgAggregateInputType = {
  rating?: true
}

export type RatingAndReviewSumAggregateInputType = {
  rating?: true
}

export type RatingAndReviewMinAggregateInputType = {
  id?: true
  rating?: true
  review?: true
  userId?: true
  courseId?: true
  createdAt?: true
}

export type RatingAndReviewMaxAggregateInputType = {
  id?: true
  rating?: true
  review?: true
  userId?: true
  courseId?: true
  createdAt?: true
}

export type RatingAndReviewCountAggregateInputType = {
  id?: true
  rating?: true
  review?: true
  userId?: true
  courseId?: true
  createdAt?: true
  _all?: true
}

export type RatingAndReviewAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which RatingAndReview to aggregate.
   */
  where?: Prisma.RatingAndReviewWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of RatingAndReviews to fetch.
   */
  orderBy?: Prisma.RatingAndReviewOrderByWithRelationInput | Prisma.RatingAndReviewOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.RatingAndReviewWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` RatingAndReviews from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` RatingAndReviews.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned RatingAndReviews
  **/
  _count?: true | RatingAndReviewCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: RatingAndReviewAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: RatingAndReviewSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: RatingAndReviewMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: RatingAndReviewMaxAggregateInputType
}

export type GetRatingAndReviewAggregateType<T extends RatingAndReviewAggregateArgs> = {
      [P in keyof T & keyof AggregateRatingAndReview]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateRatingAndReview[P]>
    : Prisma.GetScalarType<T[P], AggregateRatingAndReview[P]>
}




export type RatingAndReviewGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.RatingAndReviewWhereInput
  orderBy?: Prisma.RatingAndReviewOrderByWithAggregationInput | Prisma.RatingAndReviewOrderByWithAggregationInput[]
  by: Prisma.RatingAndReviewScalarFieldEnum[] | Prisma.RatingAndReviewScalarFieldEnum
  having?: Prisma.RatingAndReviewScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: RatingAndReviewCountAggregateInputType | true
  _avg?: RatingAndReviewAvgAggregateInputType
  _sum?: RatingAndReviewSumAggregateInputType
  _min?: RatingAndReviewMinAggregateInputType
  _max?: RatingAndReviewMaxAggregateInputType
}

export type RatingAndReviewGroupByOutputType = {
  id: string
  rating: number
  review: string
  userId: string
  courseId: string
  createdAt: Date
  _count: RatingAndReviewCountAggregateOutputType | null
  _avg: RatingAndReviewAvgAggregateOutputType | null
  _sum: RatingAndReviewSumAggregateOutputType | null
  _min: RatingAndReviewMinAggregateOutputType | null
  _max: RatingAndReviewMaxAggregateOutputType | null
}

type GetRatingAndReviewGroupByPayload<T extends RatingAndReviewGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<RatingAndReviewGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof RatingAndReviewGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], RatingAndReviewGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], RatingAndReviewGroupByOutputType[P]>
      }
    >
  >



export type RatingAndReviewWhereInput = {
  AND?: Prisma.RatingAndReviewWhereInput | Prisma.RatingAndReviewWhereInput[]
  OR?: Prisma.RatingAndReviewWhereInput[]
  NOT?: Prisma.RatingAndReviewWhereInput | Prisma.RatingAndReviewWhereInput[]
  id?: Prisma.StringFilter<"RatingAndReview"> | string
  rating?: Prisma.IntFilter<"RatingAndReview"> | number
  review?: Prisma.StringFilter<"RatingAndReview"> | string
  userId?: Prisma.StringFilter<"RatingAndReview"> | string
  courseId?: Prisma.StringFilter<"RatingAndReview"> | string
  createdAt?: Prisma.DateTimeFilter<"RatingAndReview"> | Date | string
  user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
  course?: Prisma.XOR<Prisma.CourseScalarRelationFilter, Prisma.CourseWhereInput>
}

export type RatingAndReviewOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  rating?: Prisma.SortOrder
  review?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  courseId?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  user?: Prisma.UserOrderByWithRelationInput
  course?: Prisma.CourseOrderByWithRelationInput
}

export type RatingAndReviewWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  AND?: Prisma.RatingAndReviewWhereInput | Prisma.RatingAndReviewWhereInput[]
  OR?: Prisma.RatingAndReviewWhereInput[]
  NOT?: Prisma.RatingAndReviewWhereInput | Prisma.RatingAndReviewWhereInput[]
  rating?: Prisma.IntFilter<"RatingAndReview"> | number
  review?: Prisma.StringFilter<"RatingAndReview"> | string
  userId?: Prisma.StringFilter<"RatingAndReview"> | string
  courseId?: Prisma.StringFilter<"RatingAndReview"> | string
  createdAt?: Prisma.DateTimeFilter<"RatingAndReview"> | Date | string
  user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
  course?: Prisma.XOR<Prisma.CourseScalarRelationFilter, Prisma.CourseWhereInput>
}, "id">

export type RatingAndReviewOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  rating?: Prisma.SortOrder
  review?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  courseId?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  _count?: Prisma.RatingAndReviewCountOrderByAggregateInput
  _avg?: Prisma.RatingAndReviewAvgOrderByAggregateInput
  _max?: Prisma.RatingAndReviewMaxOrderByAggregateInput
  _min?: Prisma.RatingAndReviewMinOrderByAggregateInput
  _sum?: Prisma.RatingAndReviewSumOrderByAggregateInput
}

export type RatingAndReviewScalarWhereWithAggregatesInput = {
  AND?: Prisma.RatingAndReviewScalarWhereWithAggregatesInput | Prisma.RatingAndReviewScalarWhereWithAggregatesInput[]
  OR?: Prisma.RatingAndReviewScalarWhereWithAggregatesInput[]
  NOT?: Prisma.RatingAndReviewScalarWhereWithAggregatesInput | Prisma.RatingAndReviewScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"RatingAndReview"> | string
  rating?: Prisma.IntWithAggregatesFilter<"RatingAndReview"> | number
  review?: Prisma.StringWithAggregatesFilter<"RatingAndReview"> | string
  userId?: Prisma.StringWithAggregatesFilter<"RatingAndReview"> | string
  courseId?: Prisma.StringWithAggregatesFilter<"RatingAndReview"> | string
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"RatingAndReview"> | Date | string
}

export type RatingAndReviewCreateInput = {
  id?: string
  rating: number
  review: string
  createdAt?: Date | string
  user: Prisma.UserCreateNestedOneWithoutRatingsInput
  course: Prisma.CourseCreateNestedOneWithoutRatingAndReviewsInput
}

export type RatingAndReviewUncheckedCreateInput = {
  id?: string
  rating: number
  review: string
  userId: string
  courseId: string
  createdAt?: Date | string
}

export type RatingAndReviewUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  rating?: Prisma.IntFieldUpdateOperationsInput | number
  review?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  user?: Prisma.UserUpdateOneRequiredWithoutRatingsNestedInput
  course?: Prisma.CourseUpdateOneRequiredWithoutRatingAndReviewsNestedInput
}

export type RatingAndReviewUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  rating?: Prisma.IntFieldUpdateOperationsInput | number
  review?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  courseId?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type RatingAndReviewCreateManyInput = {
  id?: string
  rating: number
  review: string
  userId: string
  courseId: string
  createdAt?: Date | string
}

export type RatingAndReviewUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  rating?: Prisma.IntFieldUpdateOperationsInput | number
  review?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type RatingAndReviewUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  rating?: Prisma.IntFieldUpdateOperationsInput | number
  review?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  courseId?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type RatingAndReviewListRelationFilter = {
  every?: Prisma.RatingAndReviewWhereInput
  some?: Prisma.RatingAndReviewWhereInput
  none?: Prisma.RatingAndReviewWhereInput
}

export type RatingAndReviewOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type RatingAndReviewCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  rating?: Prisma.SortOrder
  review?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  courseId?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type RatingAndReviewAvgOrderByAggregateInput = {
  rating?: Prisma.SortOrder
}

export type RatingAndReviewMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  rating?: Prisma.SortOrder
  review?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  courseId?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type RatingAndReviewMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  rating?: Prisma.SortOrder
  review?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  courseId?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type RatingAndReviewSumOrderByAggregateInput = {
  rating?: Prisma.SortOrder
}

export type RatingAndReviewCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.RatingAndReviewCreateWithoutUserInput, Prisma.RatingAndReviewUncheckedCreateWithoutUserInput> | Prisma.RatingAndReviewCreateWithoutUserInput[] | Prisma.RatingAndReviewUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.RatingAndReviewCreateOrConnectWithoutUserInput | Prisma.RatingAndReviewCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.RatingAndReviewCreateManyUserInputEnvelope
  connect?: Prisma.RatingAndReviewWhereUniqueInput | Prisma.RatingAndReviewWhereUniqueInput[]
}

export type RatingAndReviewUncheckedCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.RatingAndReviewCreateWithoutUserInput, Prisma.RatingAndReviewUncheckedCreateWithoutUserInput> | Prisma.RatingAndReviewCreateWithoutUserInput[] | Prisma.RatingAndReviewUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.RatingAndReviewCreateOrConnectWithoutUserInput | Prisma.RatingAndReviewCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.RatingAndReviewCreateManyUserInputEnvelope
  connect?: Prisma.RatingAndReviewWhereUniqueInput | Prisma.RatingAndReviewWhereUniqueInput[]
}

export type RatingAndReviewUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.RatingAndReviewCreateWithoutUserInput, Prisma.RatingAndReviewUncheckedCreateWithoutUserInput> | Prisma.RatingAndReviewCreateWithoutUserInput[] | Prisma.RatingAndReviewUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.RatingAndReviewCreateOrConnectWithoutUserInput | Prisma.RatingAndReviewCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.RatingAndReviewUpsertWithWhereUniqueWithoutUserInput | Prisma.RatingAndReviewUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.RatingAndReviewCreateManyUserInputEnvelope
  set?: Prisma.RatingAndReviewWhereUniqueInput | Prisma.RatingAndReviewWhereUniqueInput[]
  disconnect?: Prisma.RatingAndReviewWhereUniqueInput | Prisma.RatingAndReviewWhereUniqueInput[]
  delete?: Prisma.RatingAndReviewWhereUniqueInput | Prisma.RatingAndReviewWhereUniqueInput[]
  connect?: Prisma.RatingAndReviewWhereUniqueInput | Prisma.RatingAndReviewWhereUniqueInput[]
  update?: Prisma.RatingAndReviewUpdateWithWhereUniqueWithoutUserInput | Prisma.RatingAndReviewUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.RatingAndReviewUpdateManyWithWhereWithoutUserInput | Prisma.RatingAndReviewUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.RatingAndReviewScalarWhereInput | Prisma.RatingAndReviewScalarWhereInput[]
}

export type RatingAndReviewUncheckedUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.RatingAndReviewCreateWithoutUserInput, Prisma.RatingAndReviewUncheckedCreateWithoutUserInput> | Prisma.RatingAndReviewCreateWithoutUserInput[] | Prisma.RatingAndReviewUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.RatingAndReviewCreateOrConnectWithoutUserInput | Prisma.RatingAndReviewCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.RatingAndReviewUpsertWithWhereUniqueWithoutUserInput | Prisma.RatingAndReviewUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.RatingAndReviewCreateManyUserInputEnvelope
  set?: Prisma.RatingAndReviewWhereUniqueInput | Prisma.RatingAndReviewWhereUniqueInput[]
  disconnect?: Prisma.RatingAndReviewWhereUniqueInput | Prisma.RatingAndReviewWhereUniqueInput[]
  delete?: Prisma.RatingAndReviewWhereUniqueInput | Prisma.RatingAndReviewWhereUniqueInput[]
  connect?: Prisma.RatingAndReviewWhereUniqueInput | Prisma.RatingAndReviewWhereUniqueInput[]
  update?: Prisma.RatingAndReviewUpdateWithWhereUniqueWithoutUserInput | Prisma.RatingAndReviewUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.RatingAndReviewUpdateManyWithWhereWithoutUserInput | Prisma.RatingAndReviewUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.RatingAndReviewScalarWhereInput | Prisma.RatingAndReviewScalarWhereInput[]
}

export type RatingAndReviewCreateNestedManyWithoutCourseInput = {
  create?: Prisma.XOR<Prisma.RatingAndReviewCreateWithoutCourseInput, Prisma.RatingAndReviewUncheckedCreateWithoutCourseInput> | Prisma.RatingAndReviewCreateWithoutCourseInput[] | Prisma.RatingAndReviewUncheckedCreateWithoutCourseInput[]
  connectOrCreate?: Prisma.RatingAndReviewCreateOrConnectWithoutCourseInput | Prisma.RatingAndReviewCreateOrConnectWithoutCourseInput[]
  createMany?: Prisma.RatingAndReviewCreateManyCourseInputEnvelope
  connect?: Prisma.RatingAndReviewWhereUniqueInput | Prisma.RatingAndReviewWhereUniqueInput[]
}

export type RatingAndReviewUncheckedCreateNestedManyWithoutCourseInput = {
  create?: Prisma.XOR<Prisma.RatingAndReviewCreateWithoutCourseInput, Prisma.RatingAndReviewUncheckedCreateWithoutCourseInput> | Prisma.RatingAndReviewCreateWithoutCourseInput[] | Prisma.RatingAndReviewUncheckedCreateWithoutCourseInput[]
  connectOrCreate?: Prisma.RatingAndReviewCreateOrConnectWithoutCourseInput | Prisma.RatingAndReviewCreateOrConnectWithoutCourseInput[]
  createMany?: Prisma.RatingAndReviewCreateManyCourseInputEnvelope
  connect?: Prisma.RatingAndReviewWhereUniqueInput | Prisma.RatingAndReviewWhereUniqueInput[]
}

export type RatingAndReviewUpdateManyWithoutCourseNestedInput = {
  create?: Prisma.XOR<Prisma.RatingAndReviewCreateWithoutCourseInput, Prisma.RatingAndReviewUncheckedCreateWithoutCourseInput> | Prisma.RatingAndReviewCreateWithoutCourseInput[] | Prisma.RatingAndReviewUncheckedCreateWithoutCourseInput[]
  connectOrCreate?: Prisma.RatingAndReviewCreateOrConnectWithoutCourseInput | Prisma.RatingAndReviewCreateOrConnectWithoutCourseInput[]
  upsert?: Prisma.RatingAndReviewUpsertWithWhereUniqueWithoutCourseInput | Prisma.RatingAndReviewUpsertWithWhereUniqueWithoutCourseInput[]
  createMany?: Prisma.RatingAndReviewCreateManyCourseInputEnvelope
  set?: Prisma.RatingAndReviewWhereUniqueInput | Prisma.RatingAndReviewWhereUniqueInput[]
  disconnect?: Prisma.RatingAndReviewWhereUniqueInput | Prisma.RatingAndReviewWhereUniqueInput[]
  delete?: Prisma.RatingAndReviewWhereUniqueInput | Prisma.RatingAndReviewWhereUniqueInput[]
  connect?: Prisma.RatingAndReviewWhereUniqueInput | Prisma.RatingAndReviewWhereUniqueInput[]
  update?: Prisma.RatingAndReviewUpdateWithWhereUniqueWithoutCourseInput | Prisma.RatingAndReviewUpdateWithWhereUniqueWithoutCourseInput[]
  updateMany?: Prisma.RatingAndReviewUpdateManyWithWhereWithoutCourseInput | Prisma.RatingAndReviewUpdateManyWithWhereWithoutCourseInput[]
  deleteMany?: Prisma.RatingAndReviewScalarWhereInput | Prisma.RatingAndReviewScalarWhereInput[]
}

export type RatingAndReviewUncheckedUpdateManyWithoutCourseNestedInput = {
  create?: Prisma.XOR<Prisma.RatingAndReviewCreateWithoutCourseInput, Prisma.RatingAndReviewUncheckedCreateWithoutCourseInput> | Prisma.RatingAndReviewCreateWithoutCourseInput[] | Prisma.RatingAndReviewUncheckedCreateWithoutCourseInput[]
  connectOrCreate?: Prisma.RatingAndReviewCreateOrConnectWithoutCourseInput | Prisma.RatingAndReviewCreateOrConnectWithoutCourseInput[]
  upsert?: Prisma.RatingAndReviewUpsertWithWhereUniqueWithoutCourseInput | Prisma.RatingAndReviewUpsertWithWhereUniqueWithoutCourseInput[]
  createMany?: Prisma.RatingAndReviewCreateManyCourseInputEnvelope
  set?: Prisma.RatingAndReviewWhereUniqueInput | Prisma.RatingAndReviewWhereUniqueInput[]
  disconnect?: Prisma.RatingAndReviewWhereUniqueInput | Prisma.RatingAndReviewWhereUniqueInput[]
  delete?: Prisma.RatingAndReviewWhereUniqueInput | Prisma.RatingAndReviewWhereUniqueInput[]
  connect?: Prisma.RatingAndReviewWhereUniqueInput | Prisma.RatingAndReviewWhereUniqueInput[]
  update?: Prisma.RatingAndReviewUpdateWithWhereUniqueWithoutCourseInput | Prisma.RatingAndReviewUpdateWithWhereUniqueWithoutCourseInput[]
  updateMany?: Prisma.RatingAndReviewUpdateManyWithWhereWithoutCourseInput | Prisma.RatingAndReviewUpdateManyWithWhereWithoutCourseInput[]
  deleteMany?: Prisma.RatingAndReviewScalarWhereInput | Prisma.RatingAndReviewScalarWhereInput[]
}

export type IntFieldUpdateOperationsInput = {
  set?: number
  increment?: number
  decrement?: number
  multiply?: number
  divide?: number
}

export type RatingAndReviewCreateWithoutUserInput = {
  id?: string
  rating: number
  review: string
  createdAt?: Date | string
  course: Prisma.CourseCreateNestedOneWithoutRatingAndReviewsInput
}

export type RatingAndReviewUncheckedCreateWithoutUserInput = {
  id?: string
  rating: number
  review: string
  courseId: string
  createdAt?: Date | string
}

export type RatingAndReviewCreateOrConnectWithoutUserInput = {
  where: Prisma.RatingAndReviewWhereUniqueInput
  create: Prisma.XOR<Prisma.RatingAndReviewCreateWithoutUserInput, Prisma.RatingAndReviewUncheckedCreateWithoutUserInput>
}

export type RatingAndReviewCreateManyUserInputEnvelope = {
  data: Prisma.RatingAndReviewCreateManyUserInput | Prisma.RatingAndReviewCreateManyUserInput[]
  skipDuplicates?: boolean
}

export type RatingAndReviewUpsertWithWhereUniqueWithoutUserInput = {
  where: Prisma.RatingAndReviewWhereUniqueInput
  update: Prisma.XOR<Prisma.RatingAndReviewUpdateWithoutUserInput, Prisma.RatingAndReviewUncheckedUpdateWithoutUserInput>
  create: Prisma.XOR<Prisma.RatingAndReviewCreateWithoutUserInput, Prisma.RatingAndReviewUncheckedCreateWithoutUserInput>
}

export type RatingAndReviewUpdateWithWhereUniqueWithoutUserInput = {
  where: Prisma.RatingAndReviewWhereUniqueInput
  data: Prisma.XOR<Prisma.RatingAndReviewUpdateWithoutUserInput, Prisma.RatingAndReviewUncheckedUpdateWithoutUserInput>
}

export type RatingAndReviewUpdateManyWithWhereWithoutUserInput = {
  where: Prisma.RatingAndReviewScalarWhereInput
  data: Prisma.XOR<Prisma.RatingAndReviewUpdateManyMutationInput, Prisma.RatingAndReviewUncheckedUpdateManyWithoutUserInput>
}

export type RatingAndReviewScalarWhereInput = {
  AND?: Prisma.RatingAndReviewScalarWhereInput | Prisma.RatingAndReviewScalarWhereInput[]
  OR?: Prisma.RatingAndReviewScalarWhereInput[]
  NOT?: Prisma.RatingAndReviewScalarWhereInput | Prisma.RatingAndReviewScalarWhereInput[]
  id?: Prisma.StringFilter<"RatingAndReview"> | string
  rating?: Prisma.IntFilter<"RatingAndReview"> | number
  review?: Prisma.StringFilter<"RatingAndReview"> | string
  userId?: Prisma.StringFilter<"RatingAndReview"> | string
  courseId?: Prisma.StringFilter<"RatingAndReview"> | string
  createdAt?: Prisma.DateTimeFilter<"RatingAndReview"> | Date | string
}

export type RatingAndReviewCreateWithoutCourseInput = {
  id?: string
  rating: number
  review: string
  createdAt?: Date | string
  user: Prisma.UserCreateNestedOneWithoutRatingsInput
}

export type RatingAndReviewUncheckedCreateWithoutCourseInput = {
  id?: string
  rating: number
  review: string
  userId: string
  createdAt?: Date | string
}

export type RatingAndReviewCreateOrConnectWithoutCourseInput = {
  where: Prisma.RatingAndReviewWhereUniqueInput
  create: Prisma.XOR<Prisma.RatingAndReviewCreateWithoutCourseInput, Prisma.RatingAndReviewUncheckedCreateWithoutCourseInput>
}

export type RatingAndReviewCreateManyCourseInputEnvelope = {
  data: Prisma.RatingAndReviewCreateManyCourseInput | Prisma.RatingAndReviewCreateManyCourseInput[]
  skipDuplicates?: boolean
}

export type RatingAndReviewUpsertWithWhereUniqueWithoutCourseInput = {
  where: Prisma.RatingAndReviewWhereUniqueInput
  update: Prisma.XOR<Prisma.RatingAndReviewUpdateWithoutCourseInput, Prisma.RatingAndReviewUncheckedUpdateWithoutCourseInput>
  create: Prisma.XOR<Prisma.RatingAndReviewCreateWithoutCourseInput, Prisma.RatingAndReviewUncheckedCreateWithoutCourseInput>
}

export type RatingAndReviewUpdateWithWhereUniqueWithoutCourseInput = {
  where: Prisma.RatingAndReviewWhereUniqueInput
  data: Prisma.XOR<Prisma.RatingAndReviewUpdateWithoutCourseInput, Prisma.RatingAndReviewUncheckedUpdateWithoutCourseInput>
}

export type RatingAndReviewUpdateManyWithWhereWithoutCourseInput = {
  where: Prisma.RatingAndReviewScalarWhereInput
  data: Prisma.XOR<Prisma.RatingAndReviewUpdateManyMutationInput, Prisma.RatingAndReviewUncheckedUpdateManyWithoutCourseInput>
}

export type RatingAndReviewCreateManyUserInput = {
  id?: string
  rating: number
  review: string
  courseId: string
  createdAt?: Date | string
}

export type RatingAndReviewUpdateWithoutUserInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  rating?: Prisma.IntFieldUpdateOperationsInput | number
  review?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  course?: Prisma.CourseUpdateOneRequiredWithoutRatingAndReviewsNestedInput
}

export type RatingAndReviewUncheckedUpdateWithoutUserInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  rating?: Prisma.IntFieldUpdateOperationsInput | number
  review?: Prisma.StringFieldUpdateOperationsInput | string
  courseId?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type RatingAndReviewUncheckedUpdateManyWithoutUserInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  rating?: Prisma.IntFieldUpdateOperationsInput | number
  review?: Prisma.StringFieldUpdateOperationsInput | string
  courseId?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type RatingAndReviewCreateManyCourseInput = {
  id?: string
  rating: number
  review: string
  userId: string
  createdAt?: Date | string
}

export type RatingAndReviewUpdateWithoutCourseInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  rating?: Prisma.IntFieldUpdateOperationsInput | number
  review?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  user?: Prisma.UserUpdateOneRequiredWithoutRatingsNestedInput
}

export type RatingAndReviewUncheckedUpdateWithoutCourseInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  rating?: Prisma.IntFieldUpdateOperationsInput | number
  review?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type RatingAndReviewUncheckedUpdateManyWithoutCourseInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  rating?: Prisma.IntFieldUpdateOperationsInput | number
  review?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}



export type RatingAndReviewSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  rating?: boolean
  review?: boolean
  userId?: boolean
  courseId?: boolean
  createdAt?: boolean
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  course?: boolean | Prisma.CourseDefaultArgs<ExtArgs>
}, ExtArgs["result"]["ratingAndReview"]>

export type RatingAndReviewSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  rating?: boolean
  review?: boolean
  userId?: boolean
  courseId?: boolean
  createdAt?: boolean
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  course?: boolean | Prisma.CourseDefaultArgs<ExtArgs>
}, ExtArgs["result"]["ratingAndReview"]>

export type RatingAndReviewSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  rating?: boolean
  review?: boolean
  userId?: boolean
  courseId?: boolean
  createdAt?: boolean
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  course?: boolean | Prisma.CourseDefaultArgs<ExtArgs>
}, ExtArgs["result"]["ratingAndReview"]>

export type RatingAndReviewSelectScalar = {
  id?: boolean
  rating?: boolean
  review?: boolean
  userId?: boolean
  courseId?: boolean
  createdAt?: boolean
}

export type RatingAndReviewOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "rating" | "review" | "userId" | "courseId" | "createdAt", ExtArgs["result"]["ratingAndReview"]>
export type RatingAndReviewInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  course?: boolean | Prisma.CourseDefaultArgs<ExtArgs>
}
export type RatingAndReviewIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  course?: boolean | Prisma.CourseDefaultArgs<ExtArgs>
}
export type RatingAndReviewIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  course?: boolean | Prisma.CourseDefaultArgs<ExtArgs>
}

export type $RatingAndReviewPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "RatingAndReview"
  objects: {
    user: Prisma.$UserPayload<ExtArgs>
    course: Prisma.$CoursePayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    rating: number
    review: string
    userId: string
    courseId: string
    createdAt: Date
  }, ExtArgs["result"]["ratingAndReview"]>
  composites: {}
}

export type RatingAndReviewGetPayload<S extends boolean | null | undefined | RatingAndReviewDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$RatingAndReviewPayload, S>

export type RatingAndReviewCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<RatingAndReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: RatingAndReviewCountAggregateInputType | true
  }

export interface RatingAndReviewDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RatingAndReview'], meta: { name: 'RatingAndReview' } }
  /**
   * Find zero or one RatingAndReview that matches the filter.
   * @param {RatingAndReviewFindUniqueArgs} args - Arguments to find a RatingAndReview
   * @example
   * // Get one RatingAndReview
   * const ratingAndReview = await prisma.ratingAndReview.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends RatingAndReviewFindUniqueArgs>(args: Prisma.SelectSubset<T, RatingAndReviewFindUniqueArgs<ExtArgs>>): Prisma.Prisma__RatingAndReviewClient<runtime.Types.Result.GetResult<Prisma.$RatingAndReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one RatingAndReview that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {RatingAndReviewFindUniqueOrThrowArgs} args - Arguments to find a RatingAndReview
   * @example
   * // Get one RatingAndReview
   * const ratingAndReview = await prisma.ratingAndReview.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends RatingAndReviewFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, RatingAndReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__RatingAndReviewClient<runtime.Types.Result.GetResult<Prisma.$RatingAndReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first RatingAndReview that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RatingAndReviewFindFirstArgs} args - Arguments to find a RatingAndReview
   * @example
   * // Get one RatingAndReview
   * const ratingAndReview = await prisma.ratingAndReview.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends RatingAndReviewFindFirstArgs>(args?: Prisma.SelectSubset<T, RatingAndReviewFindFirstArgs<ExtArgs>>): Prisma.Prisma__RatingAndReviewClient<runtime.Types.Result.GetResult<Prisma.$RatingAndReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first RatingAndReview that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RatingAndReviewFindFirstOrThrowArgs} args - Arguments to find a RatingAndReview
   * @example
   * // Get one RatingAndReview
   * const ratingAndReview = await prisma.ratingAndReview.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends RatingAndReviewFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, RatingAndReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__RatingAndReviewClient<runtime.Types.Result.GetResult<Prisma.$RatingAndReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more RatingAndReviews that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RatingAndReviewFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all RatingAndReviews
   * const ratingAndReviews = await prisma.ratingAndReview.findMany()
   * 
   * // Get first 10 RatingAndReviews
   * const ratingAndReviews = await prisma.ratingAndReview.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const ratingAndReviewWithIdOnly = await prisma.ratingAndReview.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends RatingAndReviewFindManyArgs>(args?: Prisma.SelectSubset<T, RatingAndReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$RatingAndReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a RatingAndReview.
   * @param {RatingAndReviewCreateArgs} args - Arguments to create a RatingAndReview.
   * @example
   * // Create one RatingAndReview
   * const RatingAndReview = await prisma.ratingAndReview.create({
   *   data: {
   *     // ... data to create a RatingAndReview
   *   }
   * })
   * 
   */
  create<T extends RatingAndReviewCreateArgs>(args: Prisma.SelectSubset<T, RatingAndReviewCreateArgs<ExtArgs>>): Prisma.Prisma__RatingAndReviewClient<runtime.Types.Result.GetResult<Prisma.$RatingAndReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many RatingAndReviews.
   * @param {RatingAndReviewCreateManyArgs} args - Arguments to create many RatingAndReviews.
   * @example
   * // Create many RatingAndReviews
   * const ratingAndReview = await prisma.ratingAndReview.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends RatingAndReviewCreateManyArgs>(args?: Prisma.SelectSubset<T, RatingAndReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many RatingAndReviews and returns the data saved in the database.
   * @param {RatingAndReviewCreateManyAndReturnArgs} args - Arguments to create many RatingAndReviews.
   * @example
   * // Create many RatingAndReviews
   * const ratingAndReview = await prisma.ratingAndReview.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many RatingAndReviews and only return the `id`
   * const ratingAndReviewWithIdOnly = await prisma.ratingAndReview.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends RatingAndReviewCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, RatingAndReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$RatingAndReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a RatingAndReview.
   * @param {RatingAndReviewDeleteArgs} args - Arguments to delete one RatingAndReview.
   * @example
   * // Delete one RatingAndReview
   * const RatingAndReview = await prisma.ratingAndReview.delete({
   *   where: {
   *     // ... filter to delete one RatingAndReview
   *   }
   * })
   * 
   */
  delete<T extends RatingAndReviewDeleteArgs>(args: Prisma.SelectSubset<T, RatingAndReviewDeleteArgs<ExtArgs>>): Prisma.Prisma__RatingAndReviewClient<runtime.Types.Result.GetResult<Prisma.$RatingAndReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one RatingAndReview.
   * @param {RatingAndReviewUpdateArgs} args - Arguments to update one RatingAndReview.
   * @example
   * // Update one RatingAndReview
   * const ratingAndReview = await prisma.ratingAndReview.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends RatingAndReviewUpdateArgs>(args: Prisma.SelectSubset<T, RatingAndReviewUpdateArgs<ExtArgs>>): Prisma.Prisma__RatingAndReviewClient<runtime.Types.Result.GetResult<Prisma.$RatingAndReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more RatingAndReviews.
   * @param {RatingAndReviewDeleteManyArgs} args - Arguments to filter RatingAndReviews to delete.
   * @example
   * // Delete a few RatingAndReviews
   * const { count } = await prisma.ratingAndReview.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends RatingAndReviewDeleteManyArgs>(args?: Prisma.SelectSubset<T, RatingAndReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more RatingAndReviews.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RatingAndReviewUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many RatingAndReviews
   * const ratingAndReview = await prisma.ratingAndReview.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends RatingAndReviewUpdateManyArgs>(args: Prisma.SelectSubset<T, RatingAndReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more RatingAndReviews and returns the data updated in the database.
   * @param {RatingAndReviewUpdateManyAndReturnArgs} args - Arguments to update many RatingAndReviews.
   * @example
   * // Update many RatingAndReviews
   * const ratingAndReview = await prisma.ratingAndReview.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more RatingAndReviews and only return the `id`
   * const ratingAndReviewWithIdOnly = await prisma.ratingAndReview.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends RatingAndReviewUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, RatingAndReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$RatingAndReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one RatingAndReview.
   * @param {RatingAndReviewUpsertArgs} args - Arguments to update or create a RatingAndReview.
   * @example
   * // Update or create a RatingAndReview
   * const ratingAndReview = await prisma.ratingAndReview.upsert({
   *   create: {
   *     // ... data to create a RatingAndReview
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the RatingAndReview we want to update
   *   }
   * })
   */
  upsert<T extends RatingAndReviewUpsertArgs>(args: Prisma.SelectSubset<T, RatingAndReviewUpsertArgs<ExtArgs>>): Prisma.Prisma__RatingAndReviewClient<runtime.Types.Result.GetResult<Prisma.$RatingAndReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of RatingAndReviews.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RatingAndReviewCountArgs} args - Arguments to filter RatingAndReviews to count.
   * @example
   * // Count the number of RatingAndReviews
   * const count = await prisma.ratingAndReview.count({
   *   where: {
   *     // ... the filter for the RatingAndReviews we want to count
   *   }
   * })
  **/
  count<T extends RatingAndReviewCountArgs>(
    args?: Prisma.Subset<T, RatingAndReviewCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], RatingAndReviewCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a RatingAndReview.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RatingAndReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends RatingAndReviewAggregateArgs>(args: Prisma.Subset<T, RatingAndReviewAggregateArgs>): Prisma.PrismaPromise<GetRatingAndReviewAggregateType<T>>

  /**
   * Group by RatingAndReview.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RatingAndReviewGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends RatingAndReviewGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: RatingAndReviewGroupByArgs['orderBy'] }
      : { orderBy?: RatingAndReviewGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, RatingAndReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRatingAndReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the RatingAndReview model
 */
readonly fields: RatingAndReviewFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for RatingAndReview.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__RatingAndReviewClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  user<T extends Prisma.UserDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.UserDefaultArgs<ExtArgs>>): Prisma.Prisma__UserClient<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  course<T extends Prisma.CourseDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.CourseDefaultArgs<ExtArgs>>): Prisma.Prisma__CourseClient<runtime.Types.Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the RatingAndReview model
 */
export interface RatingAndReviewFieldRefs {
  readonly id: Prisma.FieldRef<"RatingAndReview", 'String'>
  readonly rating: Prisma.FieldRef<"RatingAndReview", 'Int'>
  readonly review: Prisma.FieldRef<"RatingAndReview", 'String'>
  readonly userId: Prisma.FieldRef<"RatingAndReview", 'String'>
  readonly courseId: Prisma.FieldRef<"RatingAndReview", 'String'>
  readonly createdAt: Prisma.FieldRef<"RatingAndReview", 'DateTime'>
}
    

// Custom InputTypes
/**
 * RatingAndReview findUnique
 */
export type RatingAndReviewFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RatingAndReview
   */
  select?: Prisma.RatingAndReviewSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RatingAndReview
   */
  omit?: Prisma.RatingAndReviewOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RatingAndReviewInclude<ExtArgs> | null
  /**
   * Filter, which RatingAndReview to fetch.
   */
  where: Prisma.RatingAndReviewWhereUniqueInput
}

/**
 * RatingAndReview findUniqueOrThrow
 */
export type RatingAndReviewFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RatingAndReview
   */
  select?: Prisma.RatingAndReviewSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RatingAndReview
   */
  omit?: Prisma.RatingAndReviewOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RatingAndReviewInclude<ExtArgs> | null
  /**
   * Filter, which RatingAndReview to fetch.
   */
  where: Prisma.RatingAndReviewWhereUniqueInput
}

/**
 * RatingAndReview findFirst
 */
export type RatingAndReviewFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RatingAndReview
   */
  select?: Prisma.RatingAndReviewSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RatingAndReview
   */
  omit?: Prisma.RatingAndReviewOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RatingAndReviewInclude<ExtArgs> | null
  /**
   * Filter, which RatingAndReview to fetch.
   */
  where?: Prisma.RatingAndReviewWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of RatingAndReviews to fetch.
   */
  orderBy?: Prisma.RatingAndReviewOrderByWithRelationInput | Prisma.RatingAndReviewOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for RatingAndReviews.
   */
  cursor?: Prisma.RatingAndReviewWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` RatingAndReviews from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` RatingAndReviews.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of RatingAndReviews.
   */
  distinct?: Prisma.RatingAndReviewScalarFieldEnum | Prisma.RatingAndReviewScalarFieldEnum[]
}

/**
 * RatingAndReview findFirstOrThrow
 */
export type RatingAndReviewFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RatingAndReview
   */
  select?: Prisma.RatingAndReviewSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RatingAndReview
   */
  omit?: Prisma.RatingAndReviewOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RatingAndReviewInclude<ExtArgs> | null
  /**
   * Filter, which RatingAndReview to fetch.
   */
  where?: Prisma.RatingAndReviewWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of RatingAndReviews to fetch.
   */
  orderBy?: Prisma.RatingAndReviewOrderByWithRelationInput | Prisma.RatingAndReviewOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for RatingAndReviews.
   */
  cursor?: Prisma.RatingAndReviewWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` RatingAndReviews from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` RatingAndReviews.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of RatingAndReviews.
   */
  distinct?: Prisma.RatingAndReviewScalarFieldEnum | Prisma.RatingAndReviewScalarFieldEnum[]
}

/**
 * RatingAndReview findMany
 */
export type RatingAndReviewFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RatingAndReview
   */
  select?: Prisma.RatingAndReviewSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RatingAndReview
   */
  omit?: Prisma.RatingAndReviewOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RatingAndReviewInclude<ExtArgs> | null
  /**
   * Filter, which RatingAndReviews to fetch.
   */
  where?: Prisma.RatingAndReviewWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of RatingAndReviews to fetch.
   */
  orderBy?: Prisma.RatingAndReviewOrderByWithRelationInput | Prisma.RatingAndReviewOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing RatingAndReviews.
   */
  cursor?: Prisma.RatingAndReviewWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` RatingAndReviews from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` RatingAndReviews.
   */
  skip?: number
  distinct?: Prisma.RatingAndReviewScalarFieldEnum | Prisma.RatingAndReviewScalarFieldEnum[]
}

/**
 * RatingAndReview create
 */
export type RatingAndReviewCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RatingAndReview
   */
  select?: Prisma.RatingAndReviewSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RatingAndReview
   */
  omit?: Prisma.RatingAndReviewOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RatingAndReviewInclude<ExtArgs> | null
  /**
   * The data needed to create a RatingAndReview.
   */
  data: Prisma.XOR<Prisma.RatingAndReviewCreateInput, Prisma.RatingAndReviewUncheckedCreateInput>
}

/**
 * RatingAndReview createMany
 */
export type RatingAndReviewCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many RatingAndReviews.
   */
  data: Prisma.RatingAndReviewCreateManyInput | Prisma.RatingAndReviewCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * RatingAndReview createManyAndReturn
 */
export type RatingAndReviewCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RatingAndReview
   */
  select?: Prisma.RatingAndReviewSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the RatingAndReview
   */
  omit?: Prisma.RatingAndReviewOmit<ExtArgs> | null
  /**
   * The data used to create many RatingAndReviews.
   */
  data: Prisma.RatingAndReviewCreateManyInput | Prisma.RatingAndReviewCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RatingAndReviewIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * RatingAndReview update
 */
export type RatingAndReviewUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RatingAndReview
   */
  select?: Prisma.RatingAndReviewSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RatingAndReview
   */
  omit?: Prisma.RatingAndReviewOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RatingAndReviewInclude<ExtArgs> | null
  /**
   * The data needed to update a RatingAndReview.
   */
  data: Prisma.XOR<Prisma.RatingAndReviewUpdateInput, Prisma.RatingAndReviewUncheckedUpdateInput>
  /**
   * Choose, which RatingAndReview to update.
   */
  where: Prisma.RatingAndReviewWhereUniqueInput
}

/**
 * RatingAndReview updateMany
 */
export type RatingAndReviewUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update RatingAndReviews.
   */
  data: Prisma.XOR<Prisma.RatingAndReviewUpdateManyMutationInput, Prisma.RatingAndReviewUncheckedUpdateManyInput>
  /**
   * Filter which RatingAndReviews to update
   */
  where?: Prisma.RatingAndReviewWhereInput
  /**
   * Limit how many RatingAndReviews to update.
   */
  limit?: number
}

/**
 * RatingAndReview updateManyAndReturn
 */
export type RatingAndReviewUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RatingAndReview
   */
  select?: Prisma.RatingAndReviewSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the RatingAndReview
   */
  omit?: Prisma.RatingAndReviewOmit<ExtArgs> | null
  /**
   * The data used to update RatingAndReviews.
   */
  data: Prisma.XOR<Prisma.RatingAndReviewUpdateManyMutationInput, Prisma.RatingAndReviewUncheckedUpdateManyInput>
  /**
   * Filter which RatingAndReviews to update
   */
  where?: Prisma.RatingAndReviewWhereInput
  /**
   * Limit how many RatingAndReviews to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RatingAndReviewIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * RatingAndReview upsert
 */
export type RatingAndReviewUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RatingAndReview
   */
  select?: Prisma.RatingAndReviewSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RatingAndReview
   */
  omit?: Prisma.RatingAndReviewOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RatingAndReviewInclude<ExtArgs> | null
  /**
   * The filter to search for the RatingAndReview to update in case it exists.
   */
  where: Prisma.RatingAndReviewWhereUniqueInput
  /**
   * In case the RatingAndReview found by the `where` argument doesn't exist, create a new RatingAndReview with this data.
   */
  create: Prisma.XOR<Prisma.RatingAndReviewCreateInput, Prisma.RatingAndReviewUncheckedCreateInput>
  /**
   * In case the RatingAndReview was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.RatingAndReviewUpdateInput, Prisma.RatingAndReviewUncheckedUpdateInput>
}

/**
 * RatingAndReview delete
 */
export type RatingAndReviewDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RatingAndReview
   */
  select?: Prisma.RatingAndReviewSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RatingAndReview
   */
  omit?: Prisma.RatingAndReviewOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RatingAndReviewInclude<ExtArgs> | null
  /**
   * Filter which RatingAndReview to delete.
   */
  where: Prisma.RatingAndReviewWhereUniqueInput
}

/**
 * RatingAndReview deleteMany
 */
export type RatingAndReviewDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which RatingAndReviews to delete
   */
  where?: Prisma.RatingAndReviewWhereInput
  /**
   * Limit how many RatingAndReviews to delete.
   */
  limit?: number
}

/**
 * RatingAndReview without action
 */
export type RatingAndReviewDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RatingAndReview
   */
  select?: Prisma.RatingAndReviewSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RatingAndReview
   */
  omit?: Prisma.RatingAndReviewOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RatingAndReviewInclude<ExtArgs> | null
}
